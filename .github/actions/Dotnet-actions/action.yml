name: Reusable Dotnet Workflow

inputs:
  command:
    required: true
    type: string
  projects:
    required: true
    type: string
  arguments:
    required: false
    type: string
  restoreArguments:
    required: false
    type: string
  publishTestResults:
    required: false
    type: boolean
  testRunTitle:
    required: false
    type: string
  publishWebProjects:
    required: false
    type: boolean
  zipAfterPublish:
    required: false
    type: boolean
  modifyOutputPath:
    required: false
    type: boolean
  packagesToPack:
    required: false
    type: string
  configuration:
    required: false
    type: string
  packDirectory:
    required: false
    type: string
  nobuild:
    required: false
    type: boolean
  includesymbols:
    required: false
    type: boolean
  includesource:
    required: false
    type: boolean
  requestTimeout:
    required: false
    type: string
  includeNuGetOrg:
    required: false
    type: boolean
  nugetConfigPath:
    required: false
    type: string
  noCache:
    required: false
    type: boolean
  restoreDirectory:
    required: false
    type: string
  verbosityRestore:
    required: false
    type: string
  publishPackageMetadata:
    required: false
    type: boolean
  buildProperties:
    required: false
    type: string
  verbosityPack:
    required: false
    type: string

runs:
  using: 'composite'
  steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.201'

      - name: Run dotnet ${{ inputs.command }}
        shell: pwsh
        run: |
          $command = '${{ inputs.command }}'
          if ($command -eq "restore") {
            dotnet restore "${{ inputs.projects }}" `
              --configfile "${{ inputs.nugetConfigPath }}" `
              ${{ inputs.restoreArguments }} `
              --no-cache="${{ inputs.noCache }}" `
              --packages "${{ inputs.restoreDirectory }}" `
              --verbosity "${{ inputs.verbosityRestore }}"
          } elseif ($command -eq "build") {
            dotnet build "${{ inputs.projects }}" ${{ inputs.arguments }}
          } elseif ($command -eq "test") {
            dotnet test "${{ inputs.projects }}" ${{ inputs.arguments }} `
              --logger "trx;LogFileName=${{ inputs.testRunTitle }}.trx"
            if (${{ inputs.publishTestResults }}) {
              echo "Publishing test results..."
            }
          } elseif ($command -eq "pack") {
            dotnet pack "${{ inputs.packagesToPack }}" `
              --configuration "${{ inputs.configuration }}" `
              --output "${{ inputs.packDirectory }}" `
              --no-build="${{ inputs.nobuild }}" `
              --include-symbols="${{ inputs.includesymbols }}" `
              --include-source="${{ inputs.includesource }}" `
              --property "${{ inputs.buildProperties }}" `
              --verbosity "${{ inputs.verbosityPack }}"
          } elseif ($command -eq "publish") {
            dotnet publish "${{ inputs.projects }}" `
              --configuration "${{ inputs.configuration }}" `
              --output "${{ inputs.packDirectory }}" `
              --no-build="${{ inputs.nobuild }}" `
              --verbosity "${{ inputs.verbosityPack }}"
            if (${{ inputs.publishWebProjects }}) {
              echo "Publishing web projects..."
            }
            if (${{ inputs.zipAfterPublish }}) {
              echo "Zipping published output..."
            }
          } else {
            Write-Error "Invalid command: $command"
          }
